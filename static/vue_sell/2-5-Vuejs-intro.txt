这一章的最后，我们来看一下，Vuejs的核心思想。
它包括连个方面：数据驱动和组件化。
接下来我们详细介绍一下这两个方面。
先来看一下数据驱动：DOM是数据的一种自然映射。
MVVM框架示意图：DOM对应View，Plain JavaScript Objects对应Model，Vuejs（DOM Listeners和Directives）对应ViewModel。
不同的是这里的ViewModel是一个大的Vue实例，我们先来思考一下，如果没有MVVM框架，数据和视图是如何交互的。
比如我们通过Ajax从后端获取数据，为了让视图改变，我们会手动触发DOM的改变；
再比如我们通过前端交互改变一些数据，为了让视图也发生变化，仍然需要手动触发这些DOM的改变。
那手动改变DOM不仅是一个繁琐的过程，还非常容易出错。
而我们用了Vuejs后，就省去了手动操作DOM变化的步骤了，在Vuejs里，你只需要改变数据。
Vuejs通过Directives指令，去对DOM做一层封装，当数据发生变化，会通知指令去修改对应的DOM，数据驱动DOM变化，DOM是数据的一种自然映射。
Vuejs还会对操作做一些监听，当我们修改视图的时候，Vuejs监听到这些变化，从而改变数据，这样也就形成了数据的双向绑定。
那么，Vuejs是如何做到这一点的呢？我们来看一下数据响应原理：
数据（Model）改变    驱动     视图（View）  自动更新，看看数据改变是如何驱动视图自动更新的：
这张图是从Vuejs官网扒下来的，我们来介绍一下这其中的原理：
我们有一份数据a.b，在一个Vue的对象实例化的过程中，会给a.b这一数据通过es5的object.DefineProperty给添加了一个getter和setter。
同时Vuejs会对模板做编译，解析生成一个指令对象，这里就是一个v-text指令。
每一个指令对象都会关联一个Watcher，当我们对指令的表达式a.b做求值的时候，就会触发了它的getter，这里我们就会把依赖收集到这个Watcher里面。
当我们再次改变了a.b的值的时候，我们就会触发它的setter，会通知到对应关联的Watcher，然后Watcher就会再次对a.b求值，计算对比新旧值。
当发现值改变了，Watcher又会通知到指令，调用指令的Update方法，由于指令是对DOM的封装，所以它就会调用原生DOM的方法，去更新视图。
这样，我们就完成了数据改变到视图更新的过程。

Vuejs另一个思想是组件化，组件化的目的是：扩展HTML元素，封装可重用的代码，我们来看一下这张图：
左侧是我们的页面，它被拆分成一个个小的区块，每个区块其实就对应的一个组件，组件可以嵌套，最终组合形成一个完整的页面。
在Vuejs中每个组件都对应着一个ViewModel，那最终，我们生成这个ViewModel的一个树，它和我们的DOM树是一个一一对应的关系。

接下来，我们看一下，组件的设计原则，第一个原则是：页面上每个独立的可视/可交互区域视为一个组件。
如我们以一个页面的头部、尾部，还有一些可复用区块，都可以抽象成组件。
每个组件对应一个工程目录，组件所需要的各种资源在这个目录下就近维护，这个就近维护原则，其实就体现了前端工程化思想。
它为前端开发提供了很好的分治策略，每个开发者都清楚地知道自己开发的功能单元，它的代码必然存在于对应的组件目录中。
在那个目录下，就可以找到那个功能单元所对应的内部逻辑。钥匙也好、JS也好、页面结构也好，都在那里。
在Vuejs中，可以通过.vue文件把组件依赖的模板js和样式都写在一个文件中，这可谓是把组件化就近维护思想发挥到了极致。

第三点是，页面不过是组件的容器，组件可以嵌套自由组合形成完整的页面。
在我们本次的项目开发中，我们就会把页面切分成一个个组件，我们会通过实战的方式，加深同学们对组件化开发的认识。
那么，这一章关于Vuejs的介绍，就告一段落了，下一章，我们会通过Vue-cli开启一个Vuejs的实战项目...